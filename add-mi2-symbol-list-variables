Description: <short summary of the patch>
 TODO: Put a short summary on the line above and replace this paragraph
 with a longer explanation of this change. Complete the meta-information
 with other relevant fields (see below for details). To make it easier, the
 information below has been extracted from the changelog. Adjust it or drop
 it.
 .
 gdb (7.4-1~cvs20111117.2.1) experimental; urgency=low
 .
   * add MI2 -symbol-list-variables
Author: MINAMI Hirokazu <minami@pylone.jp>

---
The information above should follow the Patch Tagging Guidelines, please
checkout http://dep.debian.net/deps/dep3/ to learn about the format. Here
are templates for supplementary fields that you might want to add:

Origin: <vendor|upstream|other>, <url of original patch>
Bug: <url in upstream bugtracker>
Bug-Debian: http://bugs.debian.org/<bugnumber>
Bug-Ubuntu: https://launchpad.net/bugs/<bugnumber>
Forwarded: <no|not-needed|url proving that it has been forwarded>
Reviewed-By: <name and email of someone who approved the patch>
Last-Update: <YYYY-MM-DD>

--- gdb-7.4.orig/gdb/mi/mi-cmds.h
+++ gdb-7.4/gdb/mi/mi-cmds.h
@@ -85,6 +85,7 @@ extern mi_cmd_argv_ftype mi_cmd_stack_li
 extern mi_cmd_argv_ftype mi_cmd_stack_list_variables;
 extern mi_cmd_argv_ftype mi_cmd_stack_select_frame;
 extern mi_cmd_argv_ftype mi_cmd_symbol_list_lines;
+extern mi_cmd_argv_ftype mi_cmd_symbol_list_variables;
 extern mi_cmd_argv_ftype mi_cmd_target_detach;
 extern mi_cmd_argv_ftype mi_cmd_target_file_get;
 extern mi_cmd_argv_ftype mi_cmd_target_file_put;
--- gdb-7.4.orig/gdb/mi/mi-cmds.c
+++ gdb-7.4/gdb/mi/mi-cmds.c
@@ -103,6 +103,7 @@ struct mi_cmd mi_cmds[] =
   { "stack-list-variables", { NULL, 0 }, mi_cmd_stack_list_variables},
   { "stack-select-frame", { NULL, 0 }, mi_cmd_stack_select_frame},
   { "symbol-list-lines", { NULL, 0 }, mi_cmd_symbol_list_lines},
+  { "symbol-list-variables", { NULL, 0 }, mi_cmd_symbol_list_variables},
   { "target-attach", { "attach", 1 }, NULL },
   { "target-detach", { NULL, 0 }, mi_cmd_target_detach },
   { "target-disconnect", { "disconnect", 0 }, 0 },
--- gdb-7.4.orig/gdb/mi/mi-symbol-cmds.c
+++ gdb-7.4/gdb/mi/mi-symbol-cmds.c
@@ -21,6 +21,10 @@
 #include "mi-cmds.h"
 #include "symtab.h"
 #include "objfiles.h"
+#include "language.h"
+#include "block.h"
+#include "value.h"
+#include "bfd.h"
 #include "ui-out.h"
 
 /* SYMBOL-LIST-LINES:
@@ -66,3 +70,141 @@ mi_cmd_symbol_list_lines (char *command,
 
   do_cleanups (cleanup_stack);
 }
+
+/* SYMBOL-LIST-VARIABLES:
+
+   Print the list of global and static variables. */
+
+void
+mi_cmd_symbol_list_variables (char *command, char **argv, int argc)
+{
+  char *regexp;
+  struct symbol_search *symbols;
+  struct symbol_search *p;
+  struct cleanup *cleanup_symbols, *cleanup_stack;
+  struct ui_out *uiout = current_uiout;
+
+  if (argc > 1)
+    error (_("-symbol-list-variables: Usage: REGEXP"));
+  else if (argc > 0){
+    regexp = argv[0];
+    ui_out_field_string (uiout, "regexp", regexp);
+  } else {
+    regexp = NULL;
+  }
+
+  search_symbols (regexp, VARIABLES_DOMAIN, 0,
+                  (char **) NULL, &symbols);
+  ui_out_field_string (uiout, "domain", "variables");
+  cleanup_symbols = make_cleanup_free_search_symbols (symbols);
+  cleanup_stack = make_cleanup_ui_out_list_begin_end (uiout, "symbols");
+
+  for (p = symbols; p; p = p->next)
+  {
+
+    if (p->msymbol){
+      struct cleanup *cleanup_tuple;
+      struct minimal_symbol *m = p->msymbol;
+      struct objfile *objfile = msymbol_objfile (m);
+      cleanup_tuple = make_cleanup_ui_out_tuple_begin_end (uiout, NULL);
+
+      ui_out_field_string (uiout, "loc", "msymbol");
+
+      if (m->filename)
+      {
+        ui_out_field_string (uiout, "file", m->filename);
+      }
+
+      if (objfile)
+      {
+        ui_out_field_core_addr (uiout, "address",
+                                get_objfile_arch (objfile),
+                                SYMBOL_VALUE_ADDRESS (m));
+      }
+      ui_out_field_string (uiout, "name", SYMBOL_SEARCH_NAME (m));
+
+      /* bfd section name */
+      if (SYMBOL_OBJ_SECTION(m) &&
+          SYMBOL_OBJ_SECTION(m)->the_bfd_section &&
+          SYMBOL_OBJ_SECTION(m)->the_bfd_section->name)
+      {
+          ui_out_field_string (uiout, "section",
+                               SYMBOL_OBJ_SECTION(m)->the_bfd_section->name);
+      }
+
+      do_cleanups (cleanup_tuple);
+
+    } else if (p->symbol){
+      struct cleanup *cleanup_tuple;
+      char *type_str;
+      struct symbol *s = p->symbol;
+      cleanup_tuple = make_cleanup_ui_out_tuple_begin_end (uiout, NULL);
+
+      switch(p->block)
+      {
+      case STATIC_BLOCK:
+        ui_out_field_string (uiout, "block", "static");
+        break;
+      case GLOBAL_BLOCK:
+        ui_out_field_string (uiout, "block", "global");
+        break;
+      default:
+        ui_out_field_int (uiout, "block", p->block);
+        break;
+      }
+
+      ui_out_field_string (uiout, "language",
+                           language_str(SYMBOL_LANGUAGE(s)));
+
+      /* dump namespace for C++?*/
+
+      switch (SYMBOL_CLASS (s))
+      {
+      case LOC_CONST:
+        ui_out_field_string (uiout, "loc", "const");
+        ui_out_field_int (uiout, "value", SYMBOL_VALUE (s));
+        break;
+      case LOC_STATIC:
+        ui_out_field_string (uiout, "loc", "static");
+        if(p->symtab && p->symtab->objfile)
+          ui_out_field_core_addr (uiout, "address",
+                                  get_objfile_arch (p->symtab->objfile),
+                                  SYMBOL_VALUE_ADDRESS (s));
+        break;
+      default:
+        ui_out_field_int (uiout, "loc", SYMBOL_CLASS (s));
+        break;
+      }
+
+      if (p->symtab && p->symtab->filename)
+      {
+        ui_out_field_string (uiout, "file", p->symtab->filename);
+        ui_out_field_int (uiout, "line", SYMBOL_LINE (s));
+      }
+
+      /* bfd section name */
+      if (SYMBOL_OBJ_SECTION(s) &&
+          SYMBOL_OBJ_SECTION(s)->the_bfd_section &&
+          SYMBOL_OBJ_SECTION(s)->the_bfd_section->name)
+      {
+          ui_out_field_string (uiout, "section",
+                               SYMBOL_OBJ_SECTION(s)->the_bfd_section->name);
+      }
+
+      ui_out_field_string (uiout, "name", SYMBOL_SEARCH_NAME (s));
+
+      type_str = type_to_string (SYMBOL_TYPE (s));
+      if (type_str)
+      {
+          ui_out_field_string (uiout, "type", type_str);
+          xfree(type_str);
+      }
+
+      do_cleanups (cleanup_tuple);
+    }
+
+  }
+  do_cleanups (cleanup_stack);
+  do_cleanups (cleanup_symbols);
+}
+
